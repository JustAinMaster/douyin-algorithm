#include <iostream>
#include <vector>
#include <list>
#include <queue>
#include "base64.h"
#include "argus.h"

extern "C" {
#include "md5.h"
#include "simon.h"
}


#include "hexdump.hpp"


// rotate right
template<class T> T __ROR__(T value, uint count)
{
    const uint nbits = sizeof(T) * 8;
    count %= nbits;

    T low = value << (nbits - count);
    value >>= count;
    value |= low;
    return value;
}

template<class T> T get_type_data(const uint8_t *ptr, int index) {
    int offset = sizeof(T) * index;
    return *(T *)(ptr + offset);
}

template<class T> void set_type_data(const uint8_t *ptr, int index, T data) {
    int offset = sizeof(T) * index;
    *(T *)(ptr + offset) = data;
}

int encrypt_ladon_input(uint8_t *hash_table, uint8_t input[16], uint8_t output[16]) {
    auto data0 = get_type_data<uint64_t>(input, 0);
    auto data1 = get_type_data<uint64_t>(input, 1);
    for (int i = 0; i < 0x22; ++i) {
        auto hash = get_type_data<uint64_t>(hash_table, i);
        data1 = hash ^ (data0 + __ROR__(data1, 8));
        data0 = data1 ^ __ROR__(data0, 0x3d);
    }
    set_type_data(output, 0, data0);
    set_type_data(output, 1, data1);
    return 0;
}

int encrypt_ladon(const char *md5hex, uint8_t *data, uint32_t size, uint8_t *output) {
    uint8_t hash_table[272 + 16] = {0};
    memcpy(hash_table, md5hex, 32);

    std::queue<uint64_t> temp;
    for (int i = 0; i < 4; ++i) {
        temp.push(get_type_data<uint64_t>(hash_table, i));
    }

    uint64_t buffer_b0;
    uint64_t buffer_b8;

    buffer_b0 = temp.front();
    temp.pop();
    buffer_b8 = temp.front();
    temp.pop();

    for (int i = 0; i < 0x22; ++i) {
        uint64_t x9 = buffer_b0;
        uint64_t x8 = buffer_b8;

//        printf("x9=%llx x8=%llx\n", x9, x8);

        x8 = __ROR__(x8, 8);
        x8 = x8 + x9;
        x8 = x8 ^ i;

        // save x8
        temp.push(x8);

        x8 = x8 ^ __ROR__(x9, 61);

//        printf("output = %llx\n", x8);

        set_type_data(hash_table, i + 1, x8);

        buffer_b0 = x8;
        buffer_b8 = temp.front();
        temp.pop();
    }

    std::cout << Hexdump(hash_table, 272 + 16) << std::endl;

    uint32_t newSize = ((size / 16) + ((size % 16) > 0 ? 1 : 0)) * 16;
    auto *newInput = new uint8_t[newSize];
    memset(newInput, 0x06, newSize); // 0x06填充
    memcpy(newInput, data, size);

    for (int i = 0; i < newSize / 16; ++i) {
        encrypt_ladon_input(hash_table, &newInput[i * 16], &output[i * 16]);
    }
    std::cout << Hexdump(output, newSize) << std::endl;
    return 0;
}

int show_size() {
    printf("char %lu\n", sizeof(char));
    printf("short %lu\n", sizeof(short));
    printf("int %lu\n", sizeof(int));
    printf("long %lu\n", sizeof(long));
    printf("long long %lu\n", sizeof(long long));
    printf("uint32_t %lu\n", sizeof(uint32_t));
    printf("uint64_t %lu\n", sizeof(uint64_t));
    return 0;
}

std::string bytes_to_hex_string(const uint8_t *data, uint32_t data_length) {
    char const hex_chars[16] = {
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
    };
    std::string result;
    for( int i = 0; i < data_length; ++i ) {
        uint8_t byte = data[i];
        result += hex_chars[ ( byte & 0xF0 ) >> 4 ];
        result += hex_chars[ ( byte & 0x0F ) >> 0 ];
    }
    return result;
}

std::string md5bytes(uint8_t *data, uint32_t size) {
    MD5Context ctx;
    md5Init(&ctx);
    md5Update(&ctx, data, size);
    md5Finalize(&ctx);
    return bytes_to_hex_string(ctx.digest, 16);
}



std::string make_ladon(uint32_t khronos) {
    uint32_t random = 0x4ec5e0ea;
    char data[32] = {0};
    std::snprintf(data, sizeof data, "%u-1588093228-1128", khronos);

    uint8_t keygen[8] = {'\0', '\0', '\0', '\0', '1', '1', '2', '8'};
    memcpy(keygen, &random, sizeof random);
    auto md5hex = md5bytes(keygen, 8);

    uint32_t size = strlen(data);
    uint32_t newSize = ((size / 16) + ((size % 16) > 0 ? 1 : 0)) * 16;

    // 扩展加随机数据
    auto *output = new uint8_t[newSize + 4];
    memcpy(output, &random, sizeof random);
    encrypt_ladon(md5hex.c_str(), (uint8_t *) data, size, &output[4]);

    std::string result = base64_encode(output, newSize + 4);

    delete[] output;
    return result;
}


int gen_table(const uint64_t args[4]) {
    uint64_t array[72 + 4] = {0};
    for (int i = 0; i < 4; ++i) {
        array[i] = args[i];
    }
    for (int i = 0; i < 72; ++i) {
        uint64_t x12 = ((0x3DC94C3A046D678BuLL >> (i % 0x3Eu)) & 1 | 0xFFFFFFFFFFFFFFFCLL);
        uint64_t x9 = array[i + 1] ^ __ROR__(array[i + 3], 3);
        uint64_t x11 = array[i + 0] ^ x12;
        x11 = x11 ^ x9;
        uint64_t x10 = (x9 << 0x3f);
        uint64_t x8 = x10 | (x9 >> 1);
        x8 = x11 ^ x8;
        array[i + 4] = x8;
        printf("%llx\n", x8);
    }
    return 0;
}


int main() {
//    uint64_t array[] = {
//            0xd743168ff0c465a4,
//            0xdb8a0e364afced16,
//            0x6d1c003a02af01b1,
//            0x69fc8b81cba594f5,
//    };
//    gen_table(array);


//    uint64_t key[4] = {0xd743168ff0c465a4, 0xdb8a0e364afced16, 0x6d1c003a02af01b1, 0x69fc8b81cba594f5};
//    uint64_t ct[2] = {0, 0};
//    uint64_t pt[2] = {0x0210048280a4d208, 0x04220db8da95ce18};
//    uint64_t pt_1[2] = {0};
//    uint64_t ct_1[2] = {0x3bf72a87efe7b868, 0x8d2b5579afc8a3a0};
//
//    simon_enc(pt, ct, key);
//    printf("Key:          %016llx %016llx %016llx %016llx\n", key[3], key[2], key[1], key[0]);
//    printf("Plaint text:  %016llx %016llx\n", pt[1], pt[0]);
//    printf("Cipher text:  %016llx %016llx\n", ct[1], ct[0]);

    const char *argus[] = {
            "wni3DJwEiI+HxHUBV7pRPrlbBVHGWB0RLrn7nDZpkgT/7b7yUnNoVRYNacd+enlrqS/1/SJZ5peIWg8VIVaXj0mgYHLjK0rGwozg+11YG1QIFo8ABvRjVgo19d2zk2s8Kl8Tuvw5xpScKcTRHW9KpX5IiCTxo/YVdDXipJFgiI/41XgVLQ6Xeb6idXWLtCyt7k/Qt54B50bT1hQ5VcVy0pZufF/4/4Ehd1+L7sHBBHQQsA==",
            "VlMKbTQsAIy4ORbvTJviXPX7vhiGcmQPBKnlyYShf0cwJ4voq++9uwan82uPkQ/I6NhvUA5jCq5QVddN0gEIcTIpKicQVVTHQVwDv33Inn1RFCpK3/DA8TRhaeF4hFSrtlFMb4DFMOqA976S6yrPxgeSdWr9DI9EwYhbyNSGX9RHRW5YKSckBS0JrDK/B2Iv2R4WcIt5WkVwu8a+3WmQHaxXMXvpzAZiVtzuXxI8SNJZ6gIk62MIXOOIZEA3BHxFUQJNyIuG5UETTukp2HieOFc8",
            "cQKgXKGLXaNm/ndNh695cdi3aUj4rh9roQZXJw6iNO1RD7//sNmsFNCOgiGPwu2qMxDbPvb7NNnrQbEah2KUY2O+wGivO6C32EIvkyY1WR0BfCv4KEMukqyK+ieWcltN5P2+D+k/nq8tAkSLDObOIcCxCti9NfATJUeezKfxNF4ws0cKn0RRtjjNfEaeOg33Cdze/3SeVhS4cWSyb31PYpdzMh5ldkUd55VFhbDSGRuboL75Q+SDOprXeqqIkYXMLo3W/TASHS1gBkuM1UUcJBka",
    };

    for (int i = 0; i < sizeof(argus) / sizeof (argus[0]); ++i) {
        decrypt_argus(argus[i]);
        printf("\n\n\n\n");
    }

//    uint8_t arr[] = {
//            0xa4,0x65,0xc4,0xf0,0x8f,0x16,0x43,0xd7,0x16,0xed,0xfc,0x4a,0x36,0x0e,0x8a,0xdb,0xb1,0x01,0xaf,0x02,0x3a,0x00,0x1c,0x6d,0xf5,0x94,0xa5,0xcb,0x81,0x8b,0xfc,0x69,0x15,0xea,0x77,0x45,0x95,0xb9,0x53,0x65,0x61,0x10,0x02,0x4a,0x45,0xbd,0x18,0x05,0xc8,0xc3,0xc7,0x2e,0xf8,0xad,0x13,0x7f,0x52,0xf0,0xa2,0x54,0x41,0x5e,0xea,0xc9,0xb7,0x7c,0x55,0x6a,0xa1,0x4b,0x9b,0x68,0xec,0x35,0xb6,0xb7,0x70,0xe4,0xe7,0x21,0xac,0x11,0x46,0x32,0xaf,0xa1,0xd1,0x6b,0x6c,0x6e,0x4e,0x61,0xe0,0x61,0x04,0xa1,0x7b,0x87,0xfa,0x73,0x34,0x68,0x40,0xf8,0xf3,0x2b,0x6c,0x2a,0x72,0x61,0xad,0x40,0xca,0xf0,0xbb,0xfb,0x79,0x75,0xb7,0x39,0x43,0x94,0x7a,0x74,0xc9,0x5b,0x36,0xbe,0x41,0xbd,0x97,0x0a,0xc5,0xe8,0x61,0xab,0xdd,0x50,0x0e,0x22,0xdc,0x72,0xe4,0xb5,0x43,0xfe,0x62,0x8c,0xdd,0x35,0x87,0xca,0x72,0x78,0x13,0x6d,0x77,0x2d,0xe0,0x7a,0x86,0x62,0x12,0x5d,0xf1,0x5b,0x7a,0x53,0x3b,0x44,0xd1,0xa9,0xd1,0xcc,0x87,0xca,0x31,0xf9,0xa0,0x87,0xb9,0x74,0x10,0xb7,0xff,0xc4,0xf9,0xc9,0x5d,0xad,0x4b,0xd2,0x8c,0xdf,0x74,0xba,0xc9,0x41,0x2c,0x84,0x66,0xe8,0xb7,0xbe,0xee,0x31,0x27,0x01,0xc6,0xa3,0x67,0x69,0x96,0x65,0xb7,0xd3,0x0d,0x05,0xf2,0xfa,0x64,0xa9,0xc3,0x5c,0xd4,0x5c,0x96,0x74,0x95,0x58,0x33,0x04,0xe8,0xcb,0x47,0xe5,0xd7,0x47,0x71,0x84,0x73,0xde,0xef,0x93,0x38,0xdb,0x23,0x46,0x66,0x8e,0x93,0x50,0x90,0xe4,0xb0,0xf9,0x1e,0xc4,0x96,0x93,0x8d,0x51,0x28,0x8d,0x9c,0xb1,0xeb,0xab,0xa5,0x01,0xcb,0xa7,0xf0,0xa5,0x09,0xfb,0x31,0x62,0x31,0x62,0x6a,0x79,0xe0,0xd5,0x41,0x58,0x96,0xc7,0x0b,0x5a,0x95,0x35,0x89,0x81,0x72,0x72,0x88,0xc7,0x72,0xe7,0x5a,0x55,0x74,0xd2,0x5a,0x6b,0x7f,0xc9,0x51,0x26,0xfa,0xae,0x47,0x6a,0xf8,0xa0,0x5c,0x80,0x12,0x0c,0x56,0x8a,0xb1,0x00,0x8f,0x79,0x80,0xa7,0x6d,0xcf,0x50,0x25,0x75,0x97,0x84,0x6a,0xd9,0xde,0xfb,0x30,0x45,0xc2,0xe6,0xa0,0xf0,0x1c,0xfe,0x2a,0x87,0x8e,0xbf,0xa9,0x20,0xff,0x46,0xdf,0x87,0x53,0x15,0x98,0x32,0xb1,0x35,0xf4,0xa5,0x34,0x6d,0xff,0x99,0xde,0x40,0x91,0xa0,0x01,0x62,0xd2,0x87,0x75,0xd8,0xfe,0x12,0xeb,0x35,0x25,0x9f,0xe0,0xa0,0x5e,0x5c,0xe1,0xc4,0x71,0x01,0xed,0x14,0x9c,0x14,0x18,0xe5,0x22,0x50,0xbd,0x48,0x35,0x47,0x12,0x40,0xac,0xd4,0x86,0x2a,0xe5,0x73,0x86,0xa0,0x0c,0x54,0x7c,0xb6,0x31,0x14,0x92,0xf2,0xfc,0x4a,0x59,0x2a,0x09,0xec,0x87,0x2b,0xf7,0xaf,0x69,0xbf,0x9c,0x71,0xe0,0xd8,0xa8,0xf8,0x20,0xe4,0x19,0x9b,0x30,0x42,0x7e,0x57,0x30,0x54,0x11,0xeb,0x4c,0x9f,0x07,0xc1,0xbe,0x0a,0x77,0x09,0xf5,0xea,0xe4,0xe2,0x5a,0xc7,0x4f,0xa9,0xc6,0x97,0x34,0x8b,0x69,0xe1,0xc2,0x45,0xa1,0x36,0x60,0xa2,0x15,0x56,0xc6,0xa5,0x82,0xfa,0x34,0x40,0x15,0x7e,0x84,0x75,0xd7,0x19,0x50,0xad,0x5b,0x61,0x7b,0x28,0x6f,0x47,0x14,0xca,0xb7,0xb9,0x90,0x5a,0x06,0x82,0xc2,0x3a,0x58,0xf4,0x84,0x3b,0x21,0x68,0x47,0x42,0xd2,0x81,0xf5,0x02,0x76,0x19,0xdd,0x13,0xef,0x93,0x2d,0x00,0x2c,0x09,0x3e,0x03,0x7f,0xa3,0x2e,0x43,0x7f,0x80,0x0d,0xb5,0xc4,0x74,0xa3,0xdb,0x1b,0x6a,0x5a,0xf8,0xe1,0x7d,0xff,0x3b,0xd1,0x00,0x7d,0x4d,0xb2,0x86,0xab,0x29,0x84,0xc6,0xc2,0x7d,0x9b,0x5a,0x0c,0x4d,0x2e,0x54,0x61
//    };
//    for (int i = 0; i < 576/8; ++i) {
//        auto v = get_type_data<uint64_t>(arr, i);
//        if ((i % 4) == 0) {
//            printf("\n");
//        }
//        printf("0x%llx ", v);
//    }

//    std::string ladon = make_ladon(1670385975);
//    std::cout << "ladon " << ladon << std::endl;

    return 0;
}
